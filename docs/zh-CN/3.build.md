# 构建和运行 Luthier

## 系统要求

### 支持的 AMD GPU

在撰写本文时，Luthier 已在 AMD Instinct MI 100（CDNA 1 GPU）上开发和测试。尚未用 Luthier 测试其他 AMD GPU。其他 CDNA GPU 可能由于错误而无法工作；RDNA GPU 也可能由于错误和一些目前未考虑的硬件差异而无法工作。随着开发的进展，我们将添加对更多 GPU 的支持。

### 操作系统

Luthier 可以在任何具有 ROCm 支持的基于 Linux 的发行版上构建和运行。在撰写本文时，AMD 正式为 Ubuntu、Red Hat Enterprise Linux 和 SUSE Linux 分发 ROCm（参见 [ROCm 安装选项](https://rocm.docs.amd.com/projects/install-on-linux/en/latest/tutorial/install-overview.html)）。其他发行版（如 Arch）也可能在官方仓库或社区维护的仓库中得到支持。

Luthier 目前不支持 Windows；这可能在未来改变。

### 必需的非 ROCm 软件

1. **CMake**：Luthier 使用 CMake 作为构建系统。**Ninja** 是 Luthier 的首选 CMake 生成器；但任何其他生成器（如 **GNU Make**）也应该可以工作。Luthier 的 CMakeLists.txt 文件位于项目的顶层目录。**需要 CMake v3.21 及以上版本**，因为这是最早支持将 HIP 作为内置 HIP/ROCm 特定 CMake 变量的语言版本。

2. **C/C++ 编译器**：如 GNU GCC 或 Clang，用于编译 Luthier 的主机部分。

3. **Python 3 解释器**：Python 包 **CXX Header Parser** 和 **PCPP** 用于为 HSA 和 HIP API 函数生成包装器。

### 必需的 ROCm 软件

1. **AMDGPU DKMS**：AMD GPU 的内核模式驱动程序。没有这个，任何基于 ROCm 的应用程序都无法在系统上运行。

2. **AMD 代码对象管理器库 (COMGR)**：用于将 Luthier 生成的目标文件链接成运行时的 HSA 可执行文件。

3. **ROCm 运行时库 (ROCr)**：在 Linux 系统上运行 AMDGPU 计算应用程序所必需的。Luthier 监控目标应用程序对 ROCr 的调用并拦截它们（包括内核启动），以插桩其设备代码并管理其执行。

4. **AMD 计算语言运行时**：为 AMD 的异构计算可移植性接口 (HIP) 提供运行时。Luthier 需要 HIP 运行时来编写和加载用户编写的设备函数进行插桩。

5. **LLVM**：Luthier 插桩的主要驱动力。LLVM 和 LLVM AMD GPU 后端用于在运行时检查和插桩目标应用程序的代码对象。Luthier 也广泛使用 LLVM 的标准库（如 ADT、字符串格式等）。在撰写本文时，Luthier 不使用随 ROCm 堆栈附带的 LLVM，而是选择使用来自 [amd-staging](https://github.com/ROCm/llvm-project/tree/amd-staging) 分支的最新 ROCm LLVM（撰写时为 21 版本）。原因如下：
   - Luthier 依赖于最近引入的 LLVM 功能，如 CodeGen 层中新的 Pass 管理器的支持。
   - ROCm LLVM 不附带有运行时类型信息 (RTTI) 启用的构建。Luthier 在 LLVM 中使用 RTTI 支持的功能，如错误检查、注释部分解析和字符串格式化。

   Luthier 在构建过程中也需要 **LLVM 项目的源代码**。原因如下：
   - AMDGPU 目标 tablegen 记录（指令和寄存器）仅在 LLVM 源代码中可用。
   - AMDGPU 后端的与目标无关的 CodeGen 类的具体接口头文件（如 `llvm::SIMachineFunctionInfo`）仅在 LLVM 源代码内部可用，对于 Luthier 的正确功能是必需的。

   编写和运行 Luthier 工具不需要 LLVM 源代码，因为所有必需的文件都将安装在 Luthier 的 include 目录下。

6. **Clang 编译器**：用于编译 Luthier 工具，主要是它们设备部分。它必须基于与构建 Luthier 本身相同的 LLVM 版本构建，否则版本不匹配可能会在构建期间导致 Luthier 编译器插件发生段错误。

7. **ROCm 设备库**：AMD 特定的设备端语言运行时库的集合，由用于编译 Luthier 及其工具的 Clang 编译器所需。

8. **ROCProfiler SDK**：用于捕获 HIP 和 HSA API 表并安装回调来监控应用程序执行。它还可以与 Luthier 的插桩功能配对的高级分析功能。

**Luthier 需要 ROCm 6.2.2+ 版本，并支持插桩代码对象 V3+**。

## 构建选项

### Luthier 特定的 CMake 选项

- **`LUTHIER_LLVM_SRC_DIR`**：如果设置，应指向 Luthier 所针对的 LLVM 二进制文件的源代码目录。如果未指定，Luthier 将检查 LLVM 二进制文件的 `llvm/Support/VCSRevision.h` 头文件，并自动下载相关的源代码修订版作为外部资源。

- **`LUTHIER_BUILD_EXAMPLES`**：如果设置为 `ON`，则构建 examples 文件夹下的示例工具。默认启用。

- **`LUTHIER_BUILD_UNIT_TESTS`**：如果设置为 `ON`，则构建 Luthier 的单元测试集。默认禁用。

- **`LUTHIER_BUILD_INTEGRATION_TESTS`**：如果设置为 `ON`，则构建 Luthier 的集成测试。默认禁用。

- **`LUTHIER_BUILD_LATEX_DOCS`**：如果设置为 `ON`，则使用 Doxygen 和 Latex 构建 Luthier 的 PDF 格式文档。默认禁用。TODO：描述 Latex 依赖项和过程。

- **`LUTHIER_BUILD_HTML_DOCS`**：如果设置为 `ON`，则使用 Doxygen 构建 Luthier 的 HTML 格式文档。默认禁用。TODO：描述文档构建过程。

### 有用的 CMake 选项和命令

更多详细信息请参阅 [CMake 文档](https://cmake.org/documentation/)。

- **`CMAKE_PREFIX_PATH`**：是一个由 `;` 分隔的路径列表，CMake 将递归搜索以通过 `find_package` 定位请求的包。较早指定的路径具有更高优先级。

- **`{PACKAGE_NAME}_DIR`**：将 PACKAGE_NAME 替换为包的名称（如 hip），可以强制 CMake 在给定目录下定位包的配置文件，并忽略所有其他提示。

- **`CMAKE_CXX_COMPILER`**、`CMAKE_C_COMPILER` 和 `CMAKE_HIP_COMPILER`**：设置所需的 C/C++/HIP 编译器的路径。

- **`-G`**：为 CMake 设置构建配置生成器（如 ninja）。

- **`CMAKE_BUILD_TYPE`**：控制主机和设备代码的构建类型。如果设置为 `Debug` 或 `RelWithDebugInfo`，可以启用调试信息。

- **`cmake --build . -v --`**：打印为每个目标执行的各个构建步骤。对调试构建过程很有用。

## 构建说明

> **注意**： `/opt/luthier/` 是 Luthier 及其需求的假设安装前缀。您不必遵循此约定。

1. 确保满足所有要求（LLVM 和 Clang 除外）；请参阅[构建要求](#构建要求)和 [ROCm 安装说明](https://rocm.docs.amd.com/en/latest/index.html)。

2. 确保满足 Luthier 的编译器和 LLVM 要求：
   1. 克隆 ROCm 分支的 LLVM 项目的 `amd-staging` 分支：
      ```bash
      git clone --depth 1 https://github.com/ROCm/llvm-project/
      ```
   2. 从 LLVM 项目配置、构建和安装所需的组件（此处使用 Ninja 生成构建文件）：
      ```bash
      mkdir llvm-project/build && cd llvm-project/build &&  \
      cmake -G Ninja -DCMAKE_POSITION_INDEPENDENT_CODE=ON \
      -DCMAKE_INSTALL_PREFIX=/opt/luthier/llvm/  \
      -DCMAKE_BUILD_TYPE=Release \
      -DLLVM_TARGETS_TO_BUILD="AMDGPU;X86"  \
      -DLLVM_ENABLE_PROJECTS="llvm;clang;lld;compiler-rt;clang-tools-extra" \
      -DLLVM_ENABLE_RUNTIMES="libcxx;libcxxabi;libunwind" \
      -DLLVM_ENABLE_EXPENSIVE_CHECKS=OFF \
      -DLIBCXX_ENABLE_SHARED=OFF \
      -DLIBCXX_ENABLE_STATIC=ON \
      -DLIBCXX_INSTALL_LIBRARY=OFF \
      -DLIBCXX_INSTALL_HEADERS=OFF \
      -DLLIBCXXABI_ENABLE_SHARED=OFF \
      -DLIBCXXABI_ENABLE_STATIC=ON \
      -DLIBCXXABI_INSTALL_STATIC_LIBRARY=OFF \
      -DLLVM_ENABLE_RTTI=ON \
      -DLLVM_OPTIMIZED_TABLEGEN=ON \
      -DCLANG_ENABLE_AMDCLANG=ON \
      -DLLVM_BUILD_TOOLS=ON \
      -DLLVM_BUILD_EXAMPLES=OFF \
      -DLLVM_INCLUDE_BENCHMARKS=OFF \
      -DLLVM_BUILD_TESTS=OFF \
      -DLLVM_INCLUDE_TESTS=OFF \
      -DCLANG_INCLUDE_TESTS=OFF \
      -DLLVM_BUILD_DOCS=OFF \
      -DLLVM_ENABLE_SPHINX=OFF \
      -DSPHINX_WARNINGS_AS_ERRORS=OFF \
      -DSPHINX_OUTPUT_MAN=OFF \
      -DLLVM_ENABLE_ASSERTIONS=OFF \
      -DLLVM_ENABLE_Z3_SOLVER=OFF \
      -DLLVM_ENABLE_ZLIB=ON \
      -DLLVM_AMDGPU_ALLOW_NPI_TARGETS=ON \
      -DCLANG_DEFAULT_PIE_ON_LINUX=0 \
      -DCLANG_DEFAULT_LINKER=lld \
      -DCLANG_DEFAULT_RTLIB=compiler-rt \
      -DCLANG_DEFAULT_UNWINDLIB=libgcc \
      -DSANITIZER_AMDGPU=OFF \
      -DPACKAGE_VENDOR="AMD" \
      -DCLANG_LINK_FLANG_LEGACY=ON \
      -DCMAKE_SKIP_BUILD_RPATH=TRUE \
      -DCMAKE_SKIP_INSTALL_RPATH=TRUE \
      -DFLANG_INCLUDE_DOCS=OFF \
      ../llvm && ninja install && cd ../../ && rm -rf llvm-project/build
      ```

      构建 LLVM 时还可以考虑以下选项：
      - `-DBUILD_SHARED_LIBS=ON` 将使用共享库而不是静态库构建 LLVM。此选项对 Luthier 的开发构建非常有用，特别是在构建带有调试信息的 LLVM 项目时。
      - `-DCMAKE_BUILD_TYPE` 可以设置为 `Debug` 或 `RelWithDebInfo` 以构建带有调试信息的 LLVM。使用 `Debug` 构建还会启用 LLVM 的调试宏和日志记录实用程序。
      - `-DLLVM_ENABLE_ASSERTIONS` 手动启用或禁用 LLVM 中的断言。建议在开发构建中启用它。
      - `-DLLVM_INSTALL_UTILS=ON` 和 `-DLLVM_INSTALL_GTEST=ON` 还将安装 GTest 以及 LLVM 的所有内部实用程序二进制文件，这两者都是在运行 Luthier 测试时所需的。

      更多关于 LLVM 构建标志的信息，请参阅 [LLVM 的 CMake 文档](https://llvm.org/docs/CMake.html)。

   3. 在 ROCm 的 LLVM 的 `amd/` 文件夹下配置、构建和安装 AMD 设备库：
      ```bash
      cd llvm-project/amd/device-libs && mkdir build && cd build &&  \
      cmake -G Ninja -DCMAKE_BUILD_TYPE=Release  \
      -DCMAKE_INSTALL_PREFIX=/opt/luthier/  \
      -DCMAKE_PREFIX_PATH="/opt/luthier/" ../ && ninja install &&
      cd ../../../ &&
      rm -rf llvm-project/amd/device-libs/build/
      ```

3. 克隆 Luthier 项目并构建它：
   ```bash
   git clone https://github.com/matinraayai/luthier && cd luthier && mkdir build && \
   cmake -DCMAKE_PREFIX_PATH="/opt/luthier;/opt/rocm" -G Ninja \
   -DCMAKE_HIP_COMPILER=/opt/luthier/llvm/bin/clang++ \
   -DCMAKE_BUILD_TYPE=Release \
   -DCMAKE_HIP_FLAGS="-O3" .. && ninja
   ```

   值得注意的标志：
   - `-DCMAKE_BUILD_TYPE` 可以设置为 `Debug` 或 `RelWithDebInfo` 以在编译的目标中发出调试信息。
   - `-DCMAKE_PREFIX_PATH` 应在 `/opt/rocm` 之后指定 `/opt/luthier`，以确保 Luthier 相关的包优先于其 ROCm 附带的对应包。
   - `CMAKE_HIP_COMPILER` 必须指向 Luthier 的 `clang++`，而不是 ROCm 附带的那个。
   - `DLLVM_DIR` 可以设置为 `/opt/luthier/llvm/lib/cmake/llvm/` 以强制 CMake 使用 Luthier LLVM。
   - `-DLUTHIER_LLVM_SRC_DIR` 可以设置为指向早期步骤中克隆的 Luthier LLVM 的源代码。
   - `-DCMAKE_HIP_FLAGS` 应为 `"-O3"`，以强制 CMake 发出优化的设备位码/二进制文件。目前，Luthier 不支持未优化的工具设备二进制文件。

> **提示**：有关满足构建要求的更多信息，请参阅 [Luthier Dev Dockerfile](../dockerfiles/luthier-dev/Dockerfile) 和 [ROCm Dev Dockerfile](../dockerfiles/rocm-dev/Dockerfile)。您可以从头开始构建开发容器，或者从 `containers.rc.northeastern.edu/luthier/luthier-dev-llvm-x-y-rocm-z` 拉取，其中 `x` 是使用的 LLVM 版本，`y` 是 LLVM 的构建类型（共享或静态），`z` 是 ROCm 版本。
