# 常见问题解答

## 我的应用程序包含动态加载的 HIP 模块。它能与 Luthier 一起工作吗？

是的。Luthier 可以捕获所有加载到设备上的代码对象。它可以捕获在每个设备上启动的所有内核，除了 HSA (ROCr) 内部使用的 BLIT 内核，因为 HSA 工具限制。更具体地说，内部的 HSA 队列无法被包装在拦截队列中，因此 Luthier 不会在 BLIT 内核启动时收到通知。一旦 ROCm 运行时团队允许工具捕获 BLIT 内核启动，我们将研究如何在我们这边支持它。

## 为什么要构建另一个版本的 LLVM？ROCm 不是已经附带了 LLVM 吗？

这背后有几个原因：

1. **暴露内部使用的寄存器和指令枚举**：AMDGPU 后端内部使用的寄存器和指令枚举。这些枚举由 Tablegen 程序在构建期间生成，但不会随 ROCm LLVM 安装或分发。Luthier 可以在其端生成这个，而不是让 LLVM 的 CMake 构建配方为我们做，但我们还没有时间研究这个。

2. **需要 RTTI 支持**：ROCm LLVM 不附带有运行时类型信息 (RTTI)，而 Luthier 使用需要 RTTI 的功能。一些示例包括制作 `llvm::Error` 或使用 `llvm::formatv` 函数。这些是有用的实用程序，使我们的开发更容易，因此我们不计划从代码库中删除它们。

3. **需要最新的 LLVM 安装**：我们需要比 ROCm 附带的更新鲜的 LLVM 安装（我们在开发容器中提供）。我们还无法创建一个干净的版本，不会破坏 HIP 编译器驱动程序（环境和位码路径会变得混乱）和 Luthier（神秘的段错误）。Luthier 唯一可靠的工作方式是如开发容器的 Dockerfiles 所示的 2 个独立 LLVM 安装。

简而言之，删除构建 Luthier 这一步是可能的；但目前，这不是我们的优先事项，需要故障排除，而我们现在没有时间做这件事。
