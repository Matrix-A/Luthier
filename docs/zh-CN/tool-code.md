# Luthier 中的工具设备代码

Luthier 允许两种方式来加载代码以进行插桩：

1. **静态方式**：如果工具的共享对象有任何 HIP 代码并用 `MARK_LUTHIER_DEVICE_MODULE` 注释，那么 HIP 将加载与工具关联的 FAT 二进制文件，其中将包含优化的位码。编译后的设备代码本身不被使用，它仅作为加载静态全局变量（如托管变量）以累积分析数据的手段。

2. **动态方式**：在这种情况下，用户可以直接从磁盘或内存加载 Luthier 工具位码。在这种情况下，如果使用任何静态变量，需要手动定义...

## 如何获取插桩函数的句柄

不幸的是，HIP 不允许在主机代码中使用指向设备函数的指针。解决这个问题的一种方法是定义一个指向实际设备函数的虚拟内核，但这最终会向 LLVM 发出的位码中添加更多内容。由于没有办法对传递给 Luthier 的指针进行编译时检查。

相反，我认为我们需要做以下事情：

1. 如果代码是静态加载的，那么每个连接到主机的设备都会获得一个包含工具代码的可执行文件。LLVM 位码保持不变，因为它是不依赖子目标的，但任何静态变量都需要为每个设备加载。因此我们有：
   1. 一个被所有人共享的位码
   2. 与位码中找到的变量对应的每个设备的静态变量列表

这意味着我们需要创建一个 Luthier 的插桩模块封装来包含这些项目。我们不需要跟踪其他东西，如设备函数，因为我们不以任何形式使用它们。

对于动态位码，由于没有要跟踪的静态变量，我们需要像 HIP 一样行事；意味着每个静态变量将获得对动态分配内存部分的外部引用。

对于静态插桩模块，我们需要提供一种方式让工具检索它。可能存在属于 Luthier 的多个静态代码对象，但我们使用 `hip_cuid` 符号来识别多个可执行文件是否相同但针对不同设备。

## 延迟加载

如果启用了延迟加载，那么工具编写者只能在数据包提交事件期间执行插桩。这是因为在其他任何时候（例如可执行文件冻结后），HIP 运行时（或任何其他运行时）可能需要将设备变量的地址写入静态变量，包括托管变量。托管变量没有在 HSA 实现，它们在 HIP 层实现。尽管 HSA 标准确实有程序分配变量或代码对象的概念，但它没有实现它。相反，当代码对象被加载到 HIP 时，运行时将动态分配变量（讽刺地使用 HSA），将该变量的初始值写入所述块，然后将所述分配变量的指针写入由代码对象使用的静态符号。因此托管变量本质上是一个指向动态分配托管指针的指针。

由于这种初始化，当用户获得 HSA 可执行文件时，无法保证托管变量指针已初始化。因此，Luthier 无法知道托管变量的指针在哪里，因此它无法正确加载插桩的可执行文件。

HIP 中的每个内核启动操作首先确保启动内核设备上的所有静态托管变量都被初始化。这意味着任何具有托管变量的代码对象都必须由 HIP 手动加载、冻结和填充。Luthier 将获得多个可执行文件冻结回调，这些回调只对应于单个内核启动。

如果启用了急切加载，同样的问题仍然存在；可执行文件冻结发生得更早，但到那时，没有托管变量被初始化。

工具代码必须启用 CUID。

（后续内容不完整）
