# 概述

## 什么是 Luthier？

Luthier 是一个用于插桩 AMD GPU 代码对象的工具。目前，它支持动态插桩，允许工具编写者：

- 查看和分析内核中的指令和基本块
- 在指令之间插入（多个）对"钩子"的调用，钩子使用 HIP 设备函数编写
- 删除、修改或添加原始应用程序的指令
- 查询或修改设备端的 ISA 可见状态，并将其记录在工具分配的一块内存中

我们计划扩展 Luthier 的功能，以包括其他用例（如静态插桩）；但目前，动态插桩是我们的首要任务。

## Luthier 支持哪些 AMD GPU 应用程序？

Luthier 支持 Linux 上任何建立在 [ROCm 运行时 (ROCr)](https://github.com/RadeonOpenCompute/ROCR-Runtime/) 之上的 AMD GPU 编程 API。这应该包括常用的运行时，如 HIP、OpenMP、OpenCL，甚至不太流行的运行时，如 AMDGPU.jl。

Luthier 目前不支持 [平台抽象层 (PAL)](https://github.com/GPUOpen-Drivers/pal) 或基于 Mesa 的后端，也不在 Windows 上进行测试。

## Luthier 是如何工作的？

（此部分待补充）

## Luthier 与 NVBit 和 GTPin 有什么不同？

Luthier 的工作方式与 [NVBit](https://github.com/NVlabs/NVBit) 和 [GTPin](https://software.intel.com/sites/landingpage/gtpin/index.html) 类似，但在其设计和使用 AMD GPU 的抽象方面有一些关键区别。主要的异同点包括：

1. **直接使用 LLVM 基础设施**：Luthier 直接使用 LLVM 基础设施来完成其繁重的工作，包括从反汇编到生成最终加载到设备上的代码对象的所有内容。

2. **不修改加载的代码对象**：与 NVBit 不同，Luthier 不修改设备上加载的代码对象来插入 trampoline；相反，它选择从头生成新的代码对象并加载它们，同时确保新加载的代码对象链接到原始加载的代码对象。

3. **使用 JIT 编译**：与 NVBit 不同，但类似于 GTPin，Luthier 使用 JIT 编译进行插桩。

4. **使用 LLVM Machine IR 描述寄存器约束**：与 GTPin 类似，Luthier 使用 LLVM Machine IR 来向 LLVM CodeGen 流水线描述其寄存器约束。而 NVBit 则通过计算函数使用的寄存器数量并将它们溢出到本地内存来处理。

5. **类似 NVBit/GTPin 的工具编写方式**：Luthier 工具的编写方式与 NVBit/GTPin 工具类似。
