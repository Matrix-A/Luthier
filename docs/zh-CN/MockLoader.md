# AMD GPU 模拟加载器

## 介绍

模拟加载器是 Luthier 开发人员非常有用的工具，它简化了插桩 Pass 的开发过程，允许他们轻松尝试不同的可能的插桩场景，而不受物理访问 AMD GPU 设备来加载其目标代码的限制。在本节中，我们将介绍 Luthier 的 `MockAMDGPULoader` 及其用法。

## 背景

按设计，Luthier 的提升和检查 Pass 仅检查目标设备上可执行内存区域的内容，如果代码对象可用，则将其作为可选的二级信息或"提示"使用。仅在 GPU 内存上直接运行检查 Pass 有以下问题：

1. 使测试检查 Pass 变得繁琐且难以扩展，因为几乎总是无法物理访问所有支持的设备。

2. 无法在没有先将代码对象加载到目标设备的情况下离线插桩代码对象。

## 设计

引入了一种称为"模拟 AMDGPU 加载器"的加载器实现，以在主机内存上动态加载和链接 AMD GPU 代码对象，而不是设备内存，从而"模拟"或仿真正常的加载过程，消除对物理 AMD GPU 的需求以利用 Luthier 的插桩 Pass。

`MockAMDGPULoader` 类的工作方式与 AMD HSA 加载器的 `hsa_executable_t` 有些相似（它确实是从后者的修改版本开始的）。它允许加载多个代码对象，甚至可以手动定义外部变量，用于解析加载的代码对象中的任何未定义变量（等效于 `hsa_executable_agent_global_variable_define`）。用户完成加载代码对象后，可以调用 `finalize()` 来完成加载过程（等效于 HSA 中的 `hsa_executable_freeze`）。

然而，模拟加载器和 HSA 可执行加载器之间存在一些重要的区别。与 HSA 加载器不同，模拟加载器：

1. **仅支持 HSA 代码对象版本 3 及以上**：代码对象版本 1 一开始就不遵循正确的 ELF 约定，其重定位枚举与更新的 HSA 代码对象版本不兼容。尽管代码对象版本 2 支持当前的 AMD GPU 重定位且格式更好，但加载器选择不支持它，因为需要检查代码对象的注释部分以区分版本 1 和 2。

2. **延迟重定位解析**：与 HSA 加载器不同，模拟加载器不会在加载代码对象时应用静态和动态重定位。相反，它将重定位解析推迟到最终化阶段。这样，加载器可以支持循环依赖的代码对象（例如，代码对象 A 定义了被代码对象 B 使用的变量 A，而代码对象 B 定义了被代码对象 A 使用的变量 B）。

3. **类型无关的变量链接**：无论类型如何，都会链接外部定义的变量和加载的代码对象中的外部变量。

4. **支持所有重定位**：支持 [AMDGPU LLVM 后端](https://llvm.org/docs/AMDGPUUsage.html#relocation-records) 文档中记录的所有重定位。

5. **支持其他操作系统的代码对象**：允许加载针对其他操作系统（包括 PAL 或 Mesa）的代码对象进行操作系统无关的测试。

6. **支持不同的架构和能力**：允许在主机内存空间中加载针对不同架构和功能的代码对象，以模拟在多个设备上链接代码对象。

值得说明的是，加载器不适用于目标文件（即没有程序头的 ELF）。

模拟加载器不是线程安全的，因为它仅用于测试。
