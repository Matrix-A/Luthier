# 介绍

## 什么是 Luthier？

Luthier 是一个用于插桩 AMD GPU 代码对象的工具。目前，它支持动态插桩，允许工具编写者：

- 查看和分析内核中的指令和基本块
- 在指令之间插入（多个）对"钩子"的调用，钩子使用 HIP 设备函数编写
- 删除、修改或添加原始应用程序的指令
- 查询或修改设备端的 ISA 可见状态，并将其记录在工具分配的一块内存中

我们计划扩展 Luthier 的功能，以包括其他用例（如静态插桩）；但目前，动态插桩是我们的首要任务。

## Luthier 支持哪些 AMD GPU 应用程序？

Luthier 支持 Linux 上任何建立在 [ROCm 运行时 (ROCr)](https://github.com/RadeonOpenCompute/ROCR-Runtime/) 之上的 AMD GPU 编程 API。这应该包括常用的运行时，如 HIP、OpenMP、OpenCL，甚至不太流行的运行时，如 AMDGPU.jl。

Luthier 目前不支持 [平台抽象层 (PAL)](https://github.com/GPUOpen-Drivers/pal) 或基于 Mesa 的后端，也不在 Windows 上进行测试。

## Luthier 是如何工作的？

Luthier 的工作方式与 [NVBit](https://github.com/NVlabs/NVBit) 和 [GTPin](https://software.intel.com/sites/landingpage/gtpin/index.html) 类似，但在其设计和使用 AMD GPU 的抽象方面有一些关键区别。在深入了解不同 Luthier 组件的工作方式之前，我们需要先介绍以下术语：

- **AMD GPU 代码对象**：一个可以加载并在 AMD GPU 上运行的 ELF 共享对象文件。其规范在 [LLVM AMDGPU 后端文档](https://llvm.org/docs/AMDGPUUsage.html)中有详细描述。每个 AMD GPU 代码对象大致与 HIP 模块（`hipModule_t`）有一对一的关系。每个已启动的内核都属于加载到设备上的 AMD GPU 代码对象。

- **目标应用程序**：要插桩的 AMD GPU 应用程序。目标应用程序包含对 AMD GPU 运行时（如 HIP）的 API 调用，将 AMD GPU 代码对象加载到 GPU 上，并启动内核。

- **插桩钩子**：由工具编写者编写的 HIP `__device__` 函数。它可以注入到内核或设备函数的指令之前或之后。钩子会被内联，并使用 Luthier intrinsic 来访问 GPU 的 ISA 可见状态。

- **Luthier Intrinsics**：一组虚拟设备函数，为 Luthier 钩子提供了一种使用汇编指令而不使用内联汇编的方法。它们类似于 LLVM intrinsic 的概念，但在不手动扩展正常 LLVM 编译流水线的情况下实现。

- **目标内核**：目标应用程序的未插桩版本。

- **已插桩内核**：目标内核的插桩版本。

### HIP/HSA API 拦截层

在最底层，Luthier 有一个 HIP/HSA API 拦截层。与 NVBit 类似，Luthier 使用 `LD_PRELOAD` 技巧在加载任何 ROCm 库之前加载自身。加载后，Luthier 使用 [rocprofiler-sdk](https://github.com/rocm/rocprofiler-sdk) API 在 HIP/HSA API 表上安装回调来拦截它们的调用。回调仅在 Luthier 或工具明确需要特定 API 或事件时才会发生。

至少，Luthier 需要拦截 HSA API 表以实现关键功能，以及 HIP 编译器 API 表以导入钩子主机句柄。Luthier 仅在需要时为用户提供方便的 HIP 运行时 API 拦截器。更多关于每个 API 拦截器如何工作的详细信息，请参阅 [HSA 拦截器](4.hsa.md#hsa-拦截器)、[HIP 运行时 API 拦截器](5.hip.md#hip-运行时-api-拦截器) 和 [HIP 编译器 API 拦截器](5.hip.md#hip-编译器-api-拦截器)。

### 什么是 HSA？为什么依赖 HSA 而不是 HIP？

简而言之，HSA（也称为 ROCm 运行时或 ROCr）是 AMD GPU 相当于 CUDA 驱动 API 的存在。更多关于 HSA 及其在 Luthier 中作用的详细信息，请参阅 [HSA 命名空间](4.hsa.md#hsa-命名空间)。我们依赖 HSA 的原因与 NVBit 依赖 CUDA 驱动 API 的原因相同：它是 ROCm 中用于计算程序的 AMD GPU 的最低公共编程层。这意味着几乎所有计算运行时都主要依赖 HSA 来在设备上加载和启动代码。为了覆盖尽可能多的潜在应用程序，并利用可用的额外低级信息，Luthier 使用 HSA 进行插桩。

## 拦截内核启动

与 CUDA 驱动 API（内核通过调用一组函数来启动）不同，AMD GPU 使用内存映射软件队列作为 GPU 命令处理器的抽象。要在 GPU 上启动内核，应用程序必须向运行时请求队列，并将内核调度包写入队列的内存。驱动程序随后异步将包提交给命令处理器。

由于没有显式函数来捕获内核启动，HSA 提供了一种称为"拦截队列"的东西，它包裹在正常的内存映射队列周围。它不是直接将包写入队列的内存，而是保留它们，并在包即将提交到真实队列之前提供回调。

为了始终拦截发送给 GPU 的所有包，Luthier 始终拦截所有对队列创建函数的调用，并用创建"拦截队列"的调用替换它们。如果工具编写者启用了该功能，"拦截队列"将在包即将被提交时调用回调。

## 代码对象反汇编和"提升"到 LLVM Machine IR

（此部分待补充）

## 如何用 Luthier 编写工具？

以下是一个 Luthier 工具编写方式的高级示例：

```c++
#include <luthier.h>
#include <hip/hip_runtime_api.h>
#include <hsa/hsa.h>

MARK_LUTHIER_DEVICE_MODULE

__managed__ int GlobalCounter = 0;

__device__ __noinline__ extern "C" void instrumentation_kernel() {
    *GlobalCounter = *GlobalCounter + 1;
}

LUTHIER_EXPORT_FUNC(instrumentation_kernel)

void instrumentKernelLaunchCallback(hsa_kernel_dispatch_packet_t packet) {
     if (not luthier_is_instrumented(packet->kernel_object)) {
         std::vector<Instr> instrVec = luthier_disassemble_kernel_object(packet->kernel_object);
         for (const auto& instr: instrVec) {
             luthier_insert_call(instr, LUTHIER_GET_HOOK_HANDLE(instrumentation_kernel), LUTHIER_IPOINT_AFTER);
         }
        luthier_override_with_instrumented(dispatchPacket);
     }
}

void luthier_at_init() {
    fprintf(stdout, "Instruction Counter Tool is launching.\n");
}

void luthier_at_term() {
     fprintf(stdout, "Number of instructions executed: %d\n", GlobalCounter);
     fprintf(stdout, "Instruction Counter Tool is terminating!\n");
}

void luthier_at_hsa_event(hsa_api_args_t* args, luthier_api_phase_t phase, hsa_api_id_t api_id) {
    if (phase == LUTHIER_API_PHASE_ENTER) {
        if (api_id == HSA_EVT_ID_KERNEL_LAUNCH) {
            fprintf(stdout, "<Intercepted kernel launch.\n");
            instrumentKernelLaunchCallback(args->hsa_evt_kernel_launch.dispatch_packet);
        }
    }
}

void atHipEvt(void* args, luthier_api_phase_t phase, int hip_api_id) {}
```

一些值得注意的要点：

1. **MARK_LUTHIER_DEVICE_MODULE 宏**：使用 Luthier 制作设备端插桩工具时，必须调用一次 `MARK_LUTHIER_DEVICE_MODULE` 宏。这将帮助 Luthier 识别与工具一起编译的 HIP 模块并跟踪它。

2. **LUTHIER_EXPORT_FUNC 宏**：需要"导出"在 Luthier 中注入到指令之间的设备函数。这将防止 HIP 编译器消除"看似"未在内核中使用的设备函数。`LUTHIER_EXPORT_FUNC` 只是一个包装插桩函数的内核，它调用该函数而不传递任何参数。该内核本身不用于在 GPU 上启动工作负载。然而，Luthier 使用与包装内核关联的"阴影主机指针"来跟踪其插桩函数。

3. **HSA 和 HIP 回调**：工具编写者需要定义两套回调，一套用于 HSA，一套用于 HIP。在示例工具中，HIP 回调什么都不做。HSA 回调在内核启动时提供用于启动内核的 `hsa_kernel_dispatch_packet_t`，并使用它来对"内核对象"（内核在设备上的地址）进行插桩和加载。

4. **反汇编内核对象**：工具编写者可以使用 `luthier_disassemble_kernel_object` 函数来提升内核对象中的指令。

5. **插入插桩函数调用**：最后，要插入对插桩函数的调用，可以使用 `luthier_insert_call` 函数。`LUTHIER_GET_HOOK_HANDLE` 将获取插桩函数的包装内核句柄。

6. **参数传递**：可以选择向插桩函数添加参数。与 NVBit 不同，Luthier 插桩函数可以直接使用 GPU 上静态和动态分配的内存。

目前，仅支持用 HIP 编写工具；但我们计划在未来为 Luthier 添加更多编写工具的方式。

### 为什么不使用 RocTracer 和 RocProfiler API 来捕获 HIP/HSA API？

Luthier 重新实现了 RocTracer 和 RocProfiler 中可用的功能，原因有三个：

1. **回调参数的 const 限制**：跟踪和分析库强制回调参数的 `const` 性质，阻止像 Luthier 这样的插桩工具修改它们。

2. **缺少必要的函数**：跟踪 API 没有捕获 Luthier 功能所需的一组必要函数，包括 HIP 应用程序启动期间调用的 `__hipRegister` 函数系列。

3. **无法阻止 HIP API 执行**：Luthier 的一些内部功能（如加载插桩代码）需要阻止 HIP API 执行。RocTracer API 不允许这种自由度。

## 代码对象管理器

代码对象管理器跟踪以下内容及其各自的代码对象：

- 已插桩内核的 HSA 可执行文件，以及它们的 HSA 可执行符号（及其内核描述符）
- 从 Luthier 工具加载的插桩函数的 HSA 可执行文件，其中包含插桩函数的位置（因为 HSA 目前不支持间接函数符号），以及与插桩函数的包装内核关联的 HSA 可执行符号

### 工具代码对象加载

与 NVBit 不同，Luthier 没有专用的"工具函数加载器"。Luthier 工具使用 HIP 编译，因此在启动期间，它们使用 `__hipRegister` 函数系列（`__hipRegisterFatBinary`、`__hipRegisterFunction`、`__hipRegisterManagedVar`、`__hipRegisterSurface`、`__hipRegisterTexture` 和 `__hipRegisterVar`）将其 FAT 二进制文件加载到 HIP 运行时。

在内部，Luthier 修改了 FAT 二进制文件的正常加载过程。它首先识别正在注册的 FAT 二进制文件是否属于 Luthier 工具。`MARK_LUTHIER_DEVICE_MODULE` 宏在 Luthier 工具关联的 FAT 二进制文件中创建一个静态托管虚拟变量，当捕获 `__hipRegisterManagedVar` 的参数时可以很容易地识别它。

如果识别到 Luthier FAT 二进制文件，其 FAT 二进制文件及其所有静态变量类型被允许正常注册。然而，内核（即 `__hipRegisterFunction` 的参数）不会向 HIP 运行时注册，因为 Luthier 模块中的内核本来就不是用于启动的。相反，内核不会向 HIP 运行时注册，而是向代码对象管理器注册以跟踪它们。

不属于 Luthier 的其他 FAT 二进制文件会被正常加载。

使用 HIP 运行时加载与 Luthier 关联的插桩函数有以下好处：

1. **无需复制加载逻辑**：不使用 HIP 运行时加载 Luthier FAT 二进制文件意味着在 Luthier 端复制相同的加载逻辑（这本身是一项非常复杂的任务），从而将宝贵的开发和维护时间从 Luthier 更重要的部分转移开来。

2. **自由使用 HIP 语言构造**：向 HIP 运行时注册意味着（与 NVBit 不同），工具编写者可以自由地在他们的插桩函数中使用 HIP 语言构造，如静态和动态、托管和设备变量。这也意味着代码对象管理器可以使用相同的"阴影主机指针"来跟踪这些构造。例如，在向插桩函数添加参数时，工具编写者不需要使用他们想要添加的参数"字符串"名称，他们可以直接使用变量。

`__hipRegister` 函数系列旨在将静态代码对象加载到 HIP 运行时。HIP 运行时有"惰性"加载 FAT 二进制的策略，这意味着只有当它需要使用与之关联的变量或内核时，才会将 FAT 二进制文件加载到 HSA。唯一的例外是如果静态托管变量包含在设备模块中，这将迫使模块从 HIP 启动任何内核时立即加载。这对 Luthier 来说是个问题，因为这意味着插桩函数不会加载到设备上。

为了解决这个问题，`MARK_LUTHIER_DEVICE` 模块在 Luthier FAT 二进制文件中定义了一个托管虚拟变量。除了用于识别 Luthier 的 FAT 二进制文件外，它还用于强制 HIP 运行时急切地加载 Luthier 模块。为了控制 Luthier 模块的加载时间，Luthier 在 HIP 中调用一个虚拟的 `nullptr_t` 内核，触发 Luthier HIP FAT 二进制文件加载到 HSA。

## 代码生成器

（此部分待补充）

## 代码提升器

代码提升器负责提升内核对象中的指令，并向工具编写者提供它们的高级视图。

## 上下文管理器

上下文管理器负责...

## Luthier 如何插桩 AMD GPU 设备代码？

![Luthier 插桩流程图](Luthier%20Instrumentation%20Diagram.png)

AMD 的 HSA 实现（也称为 ROCm 运行时或 ROCr）通常作为 Linux 平台上 ROCm 计算堆栈中的最低可编程级别存在。任何其他更高级别的运行时，如 HIP 的 AMD 运行时或 OpenCL（撰写时都在 [CLR](https://github.com/ROCm/clr) 仓库下提供）或 OpenMP 都构建在 ROCr 运行时之上。由于 ROCr 通常是所有 ROCm 事物的共同点，Luthier 主要在 HSA 级别上工作，以拦截和查询应用程序的状态并执行其插桩任务。

**注意：ROCr 并不总是计算内核的 AMD GPU 编程最低级别：**

1. **ROCT Thunk Interface**：ROCr 本身构建在 [ROCT Thunk Interface](https://github.com/ROCm/ROCT-Thunk-Interface)（或 HSAKmt）之上。HSAKmt 是 Linux ROCk 驱动程序的用户级接口。与 ROCr 类似，ROCT 可以被任意应用程序使用。理论上，可以使用 ROCT 为 AMD GPU 创建自己的计算运行时，而 Luthier 无法处理。

   此外，AMD 将 ROCT 作为静态库分发，而默认的 ROCr 构建链接这个静态库。这使得在 Luthier 中使用 ROCT 变得更加复杂，因为：
   - 拦截对 ROCT 的调用要困难得多
   - 每个基于 ROCT 的运行时实例会获得不同的"视图"

2. **平台抽象库 (PAL)**：虽然撰写时 ROCr 是 Linux 平台上 ROCm 的主要运行时，但它并不是 AMD 为计算内核开发的唯一运行时。GPUOpen 的[平台抽象库 (PAL)](https://github.com/GPUOpen-Drivers/pal)，如[这里](https://llvm.org/docs/AMDGPUUsage.html#target-triples)所述，为 Windows 和 Linux Pro 提供发布，也支持为 HSA 运行时执行代码。在 Luthier 的开发中，尚未探索针对 PAL 运行时进行插桩。

## 为什么不使用 HIP 运行时或 HIP FAT 二进制文件进行插桩？

简而言之...

## 如果 Luthier 不需要目标应用程序使用 HIP，为什么首先要捕获 HIP API？

（此部分未完成）
