# HSA 命名空间

AMD 的[异构系统架构 (HSA)](https://hsafoundation.com/) 实现，可在 [ROCr](https://github.com/ROCm/ROCR-Runtime/) 下找到，主要用于 Luthier 捕获和查询 ROCm 应用程序的状态，并执行插桩。由于其重要性，`luthier::hsa` 命名空间封装了源自 HSA 的任何内部 Luthier 操作或概念。更具体地说，`luthier::hsa`：

1. 包含包装 [HSA](https://hsafoundation.com/) API 明确定义的 C++ 类和 API，例如 `hsa_executable_t` 或 `hsa_executable_symbol_t`。每个包装类公开 Luthier 内部经常使用的有用的 HSA 相关或非相关操作。

2. 包装 HSA 未直接定义但 HSA 直接负责创建的概念或对象。主要示例是 `hsa::Instr` 类，它封装了从函数类型的 `hsa_executable_symbol_t` 的内容反汇编的 `llvm::MCInst`，该符号本身由 `hsa_loaded_code_object_t` 支持，而该对象又由 `hsa_executable_t` 支持。

3. 包含不包装 HSA API 的 C++ 类，而是用于在其上实现包装类 API。主要示例是 `hsa::Interceptor` 类，负责拦截关键的 HSA API 调用和事件，并为每个调用和事件提供回调。

`hsa` 命名空间的作用：

1. 通过将其封装在更易于管理的包装器中，解决在 Luthier 中使用 HSA 的复杂性。HSA API 是 C 语言的，在 Luthier 常用任务中使用 C++ 过于冗长。此外，在 Luthier 内部使用 HSA API 需要调用以检索原始 HSA API 表，这可能会使项目的代码行数快速增长。

2. 强制执行跨 Luthier 的 HSA 操作的正确性和正确使用。HSA 标准包含许多 AMD 不再积极维护的已弃用 API。`hsa` 命名空间只包含最基本的内容，并且只包含 HSA 的非弃用 API。在 HSA API 本身不足或可能包含需要等待 AMD 修复的错误的情况下，抽象可以补充这些不足，同时对其余组件保持透明。

3. 添加不属于 HSA 标准但 Luthier 需要存在的功能。主要示例是设备函数作为一种 `hsa_executable_symbol_t`，Luthier 尝试在内部实现它。

## HSA 拦截器

（此部分待补充）

## 数据包是如何处理的

（此部分待补充）
