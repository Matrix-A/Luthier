# 在 Luthier 中插入设备代码插桩钩子

## 介绍

Luthier 允许工具编写者在原始应用程序的任何点插入设备代码插桩"钩子"。钩子提供对插入点的 ISA 可见状态的读/写访问，并允许工具用纯 HIP 表达插桩逻辑。然后 Luthier 将钩子编译成机器代码，同时保证编译后的代码不会与应用程序状态冲突。这使得钩子比使用 LLVM 的 MIR 构建器 API 更灵活、更易于使用，并允许在不同 GPU 架构之间移植。

## 实现细节和钩子的生命周期

在底层，Luthier 工具中的钩子被编写为 HIP 中的设备函数，并设置了 `used` 属性以防止编译器删除它。在编译期间，要求 clang 编译器同时生成工具设备代码的 LLVM 位码，并使用选项 `-Xclang -fembed-bitcode=all` 将其嵌入到工具的 FAT 二进制文件中的所有 HSA 代码对象中。

在执行期间，HIP 运行时解析工具的 HIP FAT 二进制文件，并像往常一样通过 ROCr 加载必要的工具代码对象。然后，Luthier 可以通过检查其存储 ELF 轻松访问工具代码对象的嵌入 LLVM 位码，而不需要专用加载器。Luthier 中的 `ToolExecutableLoader` 负责将位码加载到 `llvm::Module` 中。由于嵌入的位码未经优化，它需要首先经过 IR 级别的优化。优化后的 IR 将成为生成插桩代码的起点。LLVM 模块由 `ToolExecutableLoader` 缓存，并在工具加载的代码对象的 HSA 可执行文件被销毁时销毁。

需要强调的是，Luthier **不使用** HIP 已经编译的插桩函数，也不尝试将它们提升到 LLVM MIR。与提升的 MIR 版本相比，从插桩代码的 LLVM IR 开始有以下好处：

1. **SSA 形式优化寄存器分配**：LLVM IR 处于 SSA 形式，并将在代码生成流水线中转换为 MIR 的 SSA 形式。提升的 MIR 不会这样做。MIR 的 SSA 形式，结合每个插桩点的活动物理寄存器列表，指导寄存器分配 Pass 优化其寄存器使用并在需要时生成溢出代码。

2. **函数内联 Pass**：LLVM IR 可以使用函数内联 Pass，这在 LLVM 中作为机器函数 Pass 不可用。这对于钩子很重要，因为它们是工具编写/编译阶段生成的设备函数的内联版本。内联还可以在早期消除设备函数的任何不必要的栈访问。

3. **栈帧信息**：LLVM IR 包含每个函数的栈帧信息，否则在打印汇编后会丢失，并且通过提升到 MIR 不容易恢复。LLVM IR 使得在插桩逻辑中创建栈对象变得容易，避免与原始内核的栈碰撞。

需要注意的是，虽然工具加载的代码对象的文本节不被 Luthier 使用，但其设备代码仍需要完全编译，以便 HIP/HSA 运行时强制加载它并初始化其静态设备变量以聚合插桩结果。

传递给 Luthier 的 `InstrumentationTask` 指定了插桩点列表以及要插入的设备钩子。`CodeGenerator` 将找到从工具加载的代码对象获得的模块中的设备钩子，并对它们执行"深拷贝"到一个全新的 LLVM 模块中，我们称之为"插桩模块"。"深拷贝"操作首先分析所有钩子的 IR 指令，并找到这些指令使用的所有模块组件。然后，任何被钩子使用的 LLVM 函数将被深拷贝到插桩模块中，而任何使用的全局变量仅声明为外部而不是深拷贝过去。这允许 ROCr 运行时正确地将插桩代码映射到工具的静态变量。如果存在，任何调试和元数据信息也将被复制到插桩模块中。

目前，插桩任务中的所有钩子必须来自同一个 LLVM 模块，即同一个工具加载的代码对象。这是确保来自两个单独文件的调试元数据不会发生碰撞。此要求如果需要可以在将来重新审视。

在复制钩子之后，Luthier 然后将提升的应用程序模块中存在的所有函数定义复制到插桩模块中，而不复制 MIR 部分。对于每个内核，它遍历提升的应用程序模块中的插桩点，并为每个生成一个 `llvm::BasicBlock`。

## 钩子与设备函数的比较

1. **ISA 可见状态保证**：与设备函数不同，钩子保证在它们接管执行时插入点的 ISA 可见状态保持不变。设备函数无法保证这一点，因为传递的参数可能需要将一些寄存器溢出到栈。

2. **强制内联和寄存器分配**：钩子本质上是强制内联的函数；Luthier 确保钩子的参数传递到寄存器中，这些寄存器既不被应用程序使用，也不被钩子查询。

## 面临的挑战

使用正常的 HIP 编译器流水线有效地完成这项任务具有挑战性，因为用 HIP 编写的插桩函数遵循调用约定的一个版本，如 [AMDGPU 后端的调用约定](https://llvm.org/docs/AMDGPUUsage.html#calling-conventions) 和 [LLVM 支持的调用约定列表](https://llvm.org/docs/LangRef.html#calling-conventions) 中所解释的。

1. **编译器假设调用者保存的寄存器可用**：基于使用的调用约定，编译器假设一组调用者保存的寄存器可用于使用。如果 Luthier 按原样修补生成的设备函数，它必须：
   1. 首先在内核中启用私有段缓冲区和扁平 scratch（如果原始应用程序还没有启用）
   2. 将调用者保存的寄存器溢出到栈，以及返回地址寄存器、栈/帧寄存器和私有段寄存器（如果它们被应用程序用于不同目的）
   3. 最后，根据其调用约定设置对插桩函数的调用。

   这种方法有以下缺点：
   - 溢出的寄存器比必要的多；它没有利用插桩点上任何可用于插桩的死寄存器。
   - 使用比必要的更多的寄存器。例如，在 GFX908 中设置调用帧可能需要设置额外的 10 个 SGPR（4 个用于私有段缓冲区，1 个用于栈指针，1 个用于帧指针，2 个用于设置目标跳转地址，2 个用于保存返回地址）。这对于插桩来说是不可接受的，特别是考虑到高性能内核中寄存器是非常稀缺的资源。
   - 一旦插桩函数被发出到普通汇编中，其帧信息（即 MIR 中的栈操作数）就会丢失，按原样使用变得更加繁琐：
     - 从 HIP 编译器的角度来看，如果插桩函数本身不调用其他函数，则不需要帧设置。这使得插入**确实**有帧的设备函数变得更加困难。
     - 如果 HIP 编译器被迫发出帧，那么为还没有设置帧的代码插入变得更加繁琐，因为我们必须自己完成，更不用说额外寄存器的破坏。
   - 启用扁平 scratch、私有段缓冲区和私有段偏移寄存器可能会改变内核的初始执行状态，需要额外的谨慎来纠正并在 LLVM Codegen 流水线插入的表尾之上进行设置。

2. **设备函数的限制**：AMDGPU 设备函数并不是为了访问调用者的父级一直到其 LLVM IR 表示而设计的。除了使用 scratch 内存的效率问题之外，这种方案使得跟踪每个寄存器的位置以及生成访问/修改状态的代码变得困难。

因此，HIP 中的插桩函数应被视为设备函数的插入。

（此部分待补充）
